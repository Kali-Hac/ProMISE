```bash

# Independently and randomly sample J spatial masks from Bernoulli(J, 1 - prob_s), prob_s is the spatial masking probability
def PSM(prob_s):
     s_mask = np.zeros([J, ])
     # number of zero masks is from 0 to J-1
     while np.mean(s_mask) == 0:
          prob = np.random.uniform(0, 1, [J, ])
          s_mask = prob >= prob_s
     return s_mask

# Independently and randomly sample f temporal masks from Bernoulli(f, 1 - prob_t), prob_t is the temporal masking probability
def PTM(prob_t):
     t_mask = np.zeros([f, ])
     # number of zero masks is from 0 to f-1
     while np.mean(t_mask) == 0:
          prob = np.random.uniform(0, 1, [f, ])
          t_mask = prob >= prob_t
     return t_mask

# Spatial skeleton reconstruction using PSM
# h with shape [batch_size, f, J, H]
# spatial_mask with shape [batch_size, J], generated by PSM(prob_s)
# gt_pos with shape [batch_size, f, J, 3]
def skeleton_recon_loss(h, spatial_mask, gt_pos):
     # Apply masks to positions in the skeleton and average unmasked representations
     mask_h = apply_mask_and_ave(h, spatial_mask)
     # Use MLP to predict ground-truth body-joint positions [batch_size, f, J, 3]
     pred_pos = MLP(mask_h)
     # Compute MSE loss between predicted positions and ground-truth positions of skeleton sequences
     s_recon_loss = MSE_loss(pred_pos, gt_pos) / batch_size
     return s_recon_loss

# temporal trajectory reconstruction using PTM
# traj_h with shape [batch_size, J, f, H]
# temporal_mask with shape [batch_size, f], generated by PTM(prob_t)
# gt_pos with shape [batch_size, f, J, 3]
def trajectory_recon_loss(traj_h, temporal_mask, gt_pos):
     # Apply masks to positions in the trajectory and average unmasked representations
     mask_traj_h = apply_mask_and_ave(traj_h, temporal_mask)
     # Use MLP to predict ground-truth trajectory positions [batch_size, J, f, 3]
     pred_pos = MLP(mask_traj_h)
     # Transpose shape [batch_size, J, f, 3] to shape [batch_size, f, J, 3] to match the original sequence shape
     pred_pos = transpose(pred_pos, [0, 2, 1, 3])
     # Compute MSE loss between predicted positions and ground-truth positions of skeleton sequences
     t_recon_loss = MSE_loss(pred_pos, gt_pos) / batch_size
     return t_recon_loss
     
def ProMISE_loss():
     return alpha * skeleton_recon_loss(h, spatial_mask, gt_pos) + (1 - alpha) * trajectory_recon_loss(traj_h, temporal_mask, gt_pos)

```
